<h2 align="center">Day 73 (27/08/2025)</h2>

## 1. Sum of All Nodes
A problem that demonstrates tree aggregation techniques and teaches recursive accumulation algorithms using node value summation for efficient binary tree total calculation and data consolidation operations.

Given a **binary tree**, find the **sum of all node values** using recursive accumulation strategy. This operation is fundamental in **tree aggregation** and **value consolidation** where you need to **compute total values** across hierarchical structures efficiently. The technique uses **recursive sum calculation** by adding current node value to sums from left and right subtrees, ensuring complete tree traversal for accurate total computation. This concept is essential in **financial calculations**, **statistical analysis**, and **data aggregation** where computing totals from hierarchical data enables comprehensive analysis and optimal decision making in tree-structured information systems.

This demonstrates **tree aggregation algorithms** and **recursive accumulation techniques** that are crucial for **value summation and efficient data consolidation operations**.

**Your task:** Implement recursive sum calculation using complete tree traversal to accumulate all node values in binary tree structure for total computation.

### Examples

**Input:**
```
    1
   / \
  2   3
```
**Output:**
```
6
```

---

**Input:**
```
  10
 /
5
```
**Output:**
```
15
```

---

## 2. Level Order Traversal
A problem that introduces breadth-first exploration and teaches queue-based traversal algorithms using level-by-level processing for efficient binary tree horizontal navigation and systematic data access operations.

Given a **binary tree**, print elements **level by level** using breadth-first traversal approach. This operation is fundamental in **level-wise processing** and **breadth-first exploration** where you need to **access nodes horizontally** across tree levels efficiently. The technique uses **queue-based level traversal** by processing nodes level by level from left to right, using queue to maintain order and ensure systematic horizontal navigation. This concept is essential in **tree printing**, **hierarchical display**, and **level-based analysis** where processing nodes by depth enables organized presentation and optimal level-wise operations in structured tree visualization systems.

This introduces **breadth-first algorithms** and **queue-based traversal techniques** that are essential for **level-wise processing and efficient horizontal navigation operations**.

**Your task:** Implement queue-based level order traversal using breadth-first approach to systematically process binary tree nodes level by level.

### Examples

**Input:**
```
    1
   / \
  2   3
```
**Output:**
```
1 2 3
```

---

**Input:**
```
  10
   \
   20
```
**Output:**
```
10 20
```

---

## 3. Find Max in Binary Tree
A problem that teaches tree optimization search and demonstrates recursive maximum finding algorithms using value comparison for efficient binary tree extremum detection and optimal value identification operations.

Given a **binary tree**, find the **maximum value node** in the tree using recursive comparison strategy. This operation is fundamental in **extremum search** and **optimization analysis** where you need to **identify optimal values** across hierarchical structures efficiently. The technique uses **recursive maximum comparison** by comparing current node value with maximum values from left and right subtrees, ensuring complete tree exploration for accurate extremum detection. This concept is essential in **performance analysis**, **optimization problems**, and **data mining** where finding maximum values enables peak identification and optimal threshold determination in value-based tree analysis systems.

This teaches **optimization search algorithms** and **recursive comparison techniques** that are crucial for **extremum detection and efficient maximum value identification operations**.

**Your task:** Implement recursive maximum search using value comparison to identify the largest node value throughout the binary tree structure.

### Examples

**Input:**
```
    3
   / \
  2   5
```
**Output:**
```
5
```

---

**Input:**
```
  1
   \
    9
```
**Output:**
```
9
```
