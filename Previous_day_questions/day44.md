<h2 align="center">Day 44 (29/07/2025)</h2>

## 1. Display Elements of a Queue
A problem that introduces fundamental queue traversal techniques and teaches non-destructive element access methods for queue inspection while preserving the original data structure integrity.

Write a function to display all elements of a queue from **front to rear** without **modifying the queue**. This operation is fundamental in **queue debugging** and **data structure inspection** where you need to **examine queue contents** without affecting the underlying FIFO structure. The technique requires understanding **non-destructive traversal** methods that preserve queue state while providing visibility into stored elements. This concept is essential in **system monitoring**, **debugging operations**, and **queue analysis** where inspecting data flow without disruption is crucial for maintaining system stability and performance diagnostics.

This teaches **non-destructive traversal algorithms** and **queue inspection techniques** that are essential for **system debugging and efficient queue state analysis operations**.

**Your task:** Implement queue traversal that displays all elements in FIFO order while maintaining the original queue structure and state.

### Examples

**Input:**
```
Queue = [10, 20, 30]
```
**Output:**
```
10 20 30
```

---

**Input:**
```
Queue = [5, 15]
```
**Output:**
```
5 15
```

---

## 2. Find the Size of a Queue
A problem that demonstrates queue metadata operations and teaches efficient size calculation techniques for dynamic data structures using built-in properties or iterative counting methods.

Given a queue, write a program to return the **number of elements** present in it. This operation is fundamental in **memory management** and **capacity planning** where you need to **monitor queue utilization** and **track data structure growth**. The technique involves understanding **size tracking mechanisms** that can be implemented through direct property access or iterative counting depending on the queue implementation. This concept is essential in **resource allocation**, **performance monitoring**, and **system optimization** where knowing data structure sizes enables efficient memory management and capacity planning decisions.

This introduces **queue metadata analysis** and **size tracking techniques** that are crucial for **resource management and efficient queue capacity monitoring operations**.

**Your task:** Implement efficient queue size calculation using appropriate methods based on the underlying queue implementation and access patterns.

### Examples

**Input:**
```
Queue = [1, 2, 3, 4]
```
**Output:**
```
4
```

---

**Input:**
```
Queue = [7]
```
**Output:**
```
1
```

---

## 3. Check if Queue is Empty
A problem that teaches queue state validation techniques and demonstrates boolean condition checking for empty data structures using efficient state detection methods for control flow operations.

Write a function to check whether the queue is **empty or not** and return a **boolean result**. This operation is fundamental in **control flow logic** and **queue processing loops** where you need to **validate queue state** before performing operations that require elements. The technique involves understanding **state validation patterns** that prevent errors in queue operations and enable safe processing workflows. This concept is essential in **iterative processing**, **consumer-producer patterns**, and **queue-based algorithms** where empty state detection prevents runtime errors and enables graceful handling of boundary conditions.

This teaches **state validation algorithms** and **boolean condition techniques** that are essential for **safe queue operations and efficient boundary condition handling**.

**Your task:** Implement reliable empty state detection that accurately identifies queue emptiness for safe operation control and error prevention.

### Examples

**Input:**
```
Queue = []
```
**Output:**
```
True
```

---

**Input:**
```
Queue = [1, 2]
```
**Output:**
```
False
```
